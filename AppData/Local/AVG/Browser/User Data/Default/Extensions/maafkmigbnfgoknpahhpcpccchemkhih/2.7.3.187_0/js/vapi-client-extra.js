"use strict";(()=>{if("object"!=typeof vAPI||vAPI.messaging instanceof Object==0||vAPI.MessagingConnection instanceof Function)return;const e=new Set,t=new Map;vAPI.MessagingConnection=class{constructor(e,s){this.messaging=vAPI.messaging,this.handler=e,this.id=s.id,this.to=s.to,this.toToken=s.toToken,this.from=s.from,this.fromToken=s.fromToken,this.checkTimer=void 0;const n=vAPI.MessagingConnection;void 0===n.pagehide&&(n.pagehide=()=>{for(const e of t.values())e.disconnect(),e.handler(e.toDetails("connectionBroken"))},window.addEventListener("pagehide",n.pagehide))}toDetails(e,t){return{what:e,id:this.id,from:this.from,fromToken:this.fromToken,to:this.to,toToken:this.toToken,payload:t}}disconnect(){void 0!==this.checkTimer&&(clearTimeout(this.checkTimer),this.checkTimer=void 0),t.delete(this.id);const e=this.messaging.getPort();null!==e&&e.postMessage({channel:"vapi",msg:this.toDetails("connectionBroken")})}checkAsync(){void 0!==this.checkTimer&&clearTimeout(this.checkTimer),this.checkTimer=vAPI.setTimeout((()=>{this.check()}),499)}check(){if(this.checkTimer=void 0,!1===t.has(this.id))return;const e=this.messaging.getPort();null!==e&&(e.postMessage({channel:"vapi",msg:this.toDetails("connectionCheck")}),this.checkAsync())}receive(e){switch(e.what){case"connectionAccepted":this.toToken=e.toToken,this.handler(e),this.checkAsync();break;case"connectionBroken":case"connectionRefused":t.delete(this.id),this.handler(e);break;case"connectionMessage":this.handler(e),this.checkAsync();break;case"connectionCheck":const s=this.messaging.getPort();if(null===s)return;t.has(this.id)?this.checkAsync():(e.what="connectionBroken",s.postMessage({channel:"vapi",msg:e}))}}send(e){const t=this.messaging.getPort();null!==t&&t.postMessage({channel:"vapi",msg:this.toDetails("connectionMessage",e)})}static addListener(t){e.add(t),vAPI.messaging.getPort()}static removeListener(t){e.delete(t)}static connectTo(e,s,n){const o=vAPI.messaging.getPort();if(null===o)return;const i=new vAPI.MessagingConnection(n,{id:`${e}-${s}-${vAPI.sessionId}`,to:s,from:e,fromToken:o.name});return t.set(i.id,i),o.postMessage({channel:"vapi",msg:{what:"connectionRequested",id:i.id,from:e,fromToken:o.name,to:s}}),i.id}static disconnectFrom(e){const s=t.get(e);void 0!==s&&s.disconnect()}static sendTo(e,s){const n=t.get(e);void 0!==n&&n.send(s)}static canDestroyPort(){return 0===e.length&&0===t.size}static mustDestroyPort(){if(0!==t.size){for(const e of t.values())e.receive({what:"connectionBroken"});t.clear()}}static canProcessMessage(s){if("vapi"===s.channel)switch(s.msg.what){case"connectionAccepted":case"connectionBroken":case"connectionCheck":case"connectionMessage":case"connectionRefused":{const e=t.get(s.msg.id);if(void 0===e)break;return e.receive(s.msg),!0}case"connectionRequested":if(0===e.length)return;const n=vAPI.messaging.getPort();if(null===n)break;let o,i;for(o of e)if(i=o(s.msg),void 0!==i)break;if(void 0===i)break;if(!0===i){s.msg.what="connectionAccepted",s.msg.toToken=n.name;const e=new vAPI.MessagingConnection(o,s.msg);t.set(e.id,e)}else s.msg.what="connectionRefused";return n.postMessage(s),!0}}},vAPI.messaging.extensions.push(vAPI.MessagingConnection)})(),(()=>{if("object"!=typeof vAPI||vAPI.messaging instanceof Object==0||vAPI.broadcastListener instanceof Object)return;const e=new Set;vAPI.broadcastListener={add:function(t){e.add(t),vAPI.messaging.getPort()},remove:function(t){e.delete(t)},canDestroyPort:()=>0===e.size,mustDestroyPort(){e.clear()},canProcessMessage(t){if(!1!==t.broadcast)for(const s of e)s(t.msg)}},vAPI.messaging.extensions.push(vAPI.broadcastListener)})();